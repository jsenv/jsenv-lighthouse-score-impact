import { createLogger } from "@jsenv/logger"
import {
  wrapExternalFunction,
  createCancellationTokenForProcess,
  assertAndNormalizeDirectoryUrl,
  resolveUrl,
  readFile,
} from "@jsenv/util"
import {
  getPullRequestLighthouseComment,
  commentToGistId,
} from "./internal/getPullRequestLighthouseComment.js"
import { createGist } from "./internal/createGist.js"
import { createPullRequestComment } from "./internal/createPullRequestComment.js"
import { createPullRequestCommentMarkdown } from "./internal/createPullRequestCommentMarkdown.js"
import { updateGist } from "./internal/updateGist.js"
import { updatePullRequestComment } from "./internal/updatePullRequestComment.js"
import {
  createUnexpectedGithubApiTokenError,
  createUnexpectedRepositoryOwnerError,
  createUnexpectedRepositoryNameError,
  createUnexpectedPullRequestNumberError,
} from "./internal/errors.js"
import { readGithubWorkflowEnv, readPullRequestNumber } from "./internal/github-workflow-env.js"

const regexForMergingLighthouseImpact = /<!-- Generated by @jsenv\/github-pull-request-lighthouse-impact -->/

export const reportLighthouseImpactIntoGithubPullRequest = async ({
  cancellationToken = createCancellationTokenForProcess(),
  logLevel,

  githubApiTokenForGist,
  projectDirectoryUrl,
  baseSnapshotFileRelativeUrl,
  headSnapshotFileRelativeUrl,
}) => {
  return wrapExternalFunction(async () => {
    const logger = createLogger({ logLevel })
    projectDirectoryUrl = assertAndNormalizeDirectoryUrl(projectDirectoryUrl)

    const {
      repositoryOwner,
      repositoryName,
      pullRequestBase,
      pullRequestHead,
      githubToken,
    } = readGithubWorkflowEnv()
    const pullRequestNumber = await readPullRequestNumber({ logger })

    if (typeof githubApiTokenForGist !== "string") {
      throw createUnexpectedGithubApiTokenError({ githubApiToken: githubApiTokenForGist })
    }
    if (typeof baseSnapshotFileRelativeUrl !== "string") {
      throw new TypeError(
        `baseSnapshotFileRelativeUrl must be a string, got ${baseSnapshotFileRelativeUrl}`,
      )
    }
    if (typeof headSnapshotFileRelativeUrl !== "string") {
      throw new TypeError(
        `headSnapshotFileRelativeUrl must be a string, got ${headSnapshotFileRelativeUrl}`,
      )
    }

    const baseSnapshotFileUrl = resolveUrl(baseSnapshotFileRelativeUrl, projectDirectoryUrl)
    const headSnapshotFileUrl = resolveUrl(headSnapshotFileRelativeUrl, projectDirectoryUrl)
    const snapshotsPromise = Promise.all([
      readFile(baseSnapshotFileUrl),
      readFile(headSnapshotFileUrl),
    ])
    const existingCommentPromise = getPullRequestLighthouseComment({
      githubApiToken,
      repositoryOwner,
      repositoryName,
      pullRequestNumber,
    })

    logger.debug(
      `searching lighthouse comment in pull request at ${getPullRequestHref({
        repositoryOwner,
        repositoryName,
        pullRequestNumber,
      })}`,
    )

    const [
      [baseSnapshotFileContent, headSnapshotFileContent],
      existingComment,
    ] = await Promise.all([snapshotsPromise, existingCommentPromise])

    const commentBody = generateCommentBody({
      baseSnapshotFileContent,
      headSnapshotFileContent,
    })

    if (existingComment) {
      logger.debug(`comment found, updating it
--- comment href ---
${existingComment.html_url}`)
      const comment = await updateGistAndUpdatePullRequestComment({
        githubApiToken,
        repositoryOwner,
        repositoryName,
        pullRequestNumber,
        comment: existingComment,
        commentBody,
      })
      logger.info(`comment updated at ${existingComment.html_url}`)
      return comment
    }

    logger.debug(`comment not found, creating a comment`)
    const { comment, gist } = await createGistAndCommentPullRequest({
      githubApiToken,
      repositoryOwner,
      repositoryName,
      pullRequestNumber,
      commentBody,
    })
    logger.info(`comment created at ${comment.html_url}`)
    return { comment, gist }
  })
}

const updateGistAndUpdatePullRequestComment = async ({
  lighthouseReport,
  lighthouseProductionReport,
  githubApiToken,
  repositoryOwner,
  repositoryName,
  pullRequestNumber,
  commentBody,
}) => {
  // here we should ensure the gist still exists
  // and create it if it was deleted somehow
  const gistId = commentToGistId(comment)
  console.log(`update gist at https://gist.github.com/${gistId}`)
  const gist = await updateGist({
    githubApiToken,
    gistId,
    files: getGistFiles({
      lighthouseReport,
      repositoryOwner,
      repositoryName,
      pullRequestNumber,
    }),
  })
  console.log("gist update success")

  console.log(`update comment at ${comment.html_url}`)
  const commentId = comment.id
  const comment = await updatePullRequestComment({
    githubApiToken,
    repositoryOwner,
    repositoryName,
    pullRequestNumber,
    commentId,
    commentBody: createPullRequestCommentMarkdown({
      lighthouseReport,
      lighthouseProductionReport,
      gistId,
    }),
  })
  console.log("comment update success")
  return { gist, comment }
}

const createGistAndCommentPullRequest = async ({
  lighthouseReport,
  lighthouseProductionReport,
  githubApiToken,
  repositoryOwner,
  repositoryName,
  pullRequestNumber,
}) => {
  console.log(`create gist`)
  const gist = await createGist({
    githubApiToken,
    files: getGistFiles({ lighthouseReport, repositoryOwner, repositoryName, pullRequestNumber }),
  })
  console.log(`gist created at ${gist.html_url}`)

  console.log(
    `create pull request comment for ${getPullRequestHref({
      repositoryOwner,
      repositoryName,
      pullRequestNumber,
    })}`,
  )
  const comment = await createPullRequestComment({
    githubApiToken,
    repositoryOwner,
    repositoryName,
    pullRequestNumber,
    commentBody: createPullRequestCommentMarkdown({
      lighthouseReport,
      lighthouseProductionReport,
      gistId: gist.id,
    }),
  })
  console.log(`comment created at ${comment.html_url}`)

  return { gist, comment }
}

const getGistFiles = ({ lighthouseReport, repositoryOwner, repositoryName, pullRequestNumber }) => {
  return {
    [`${repositoryOwner}-${repositoryName}-pr-${pullRequestNumber}-lighthouse-report.json`]: {
      content: JSON.stringify(lighthouseReport),
    },
  }
}

const getPullRequestHref = ({ repositoryOwner, repositoryName, pullRequestNumber }) =>
  `https://github.com/${repositoryOwner}/${repositoryName}/pull/${pullRequestNumber}`
